# Архитектура игры HseRogue

## Разработчики
- Бубнов Данил
- Марьин Глеб
- Лучинин Алексей
- Онофрийчук Илья

## Глоссарий
Забег — игра от старта до финальной точки или до смерти

## Общие сведения о системе

### Назначения системы
HseRogue — игра в жанре roguelike с консольной графикой

### Границы системы
- Игра однопользовательская
- Управление с помощью клавиатуры
- Переназначения клавиш нет
- В игре нет прогрессии между забегами
- Сохранений нет
- Игра пошаговая. Без действий игрока ничего происходить не будет
- Есть заранее созданные уровни, а также уровни, которые генерируются с использованием случайности
- Уровни одинакового размера (если хочется сделать уровень меньше, то можно сделать границу из непроходимых блоков)
- Игроки не могут добавлять свои уровни и другой контент
- Размер пользовательского интерфейса нельзя менять
- Графика двумерная
- Игровое поле состоит из блоков, у каждого блока есть координаты x и y, в каждом блоке могут быть размещены одна или несколько игровых сущностей
- Основной язык английский, но должна быть возможность легко добавить перевод на другие языки

### Контекст системы
Игра должна работать прямо на устройствах пользователей в консоли. Должно быть поддержано максимально возможное число платформ

## Architectural drivers

### Технические ограничения
- Для выбранного языка программирования должна быть библиотека для работы с консолью (по типу ncurses)

### Бизнес ограничения
- Для разработки системы будет около 2 месяцев
- Промежуточные результаты должны быть раз в 1-2 недели
- Нужно будет использовать паттерны и шаблоны проектирования при разработке

### Качественные характеристики системы
- Производительность не важна (игра простая с простой графикой)
- Важна готовность системы к изменениям

### Ключевые функциональные требования
- Должна быть консольная графика
- Должен быть персонаж, способный перемещаться по карте
- Должны быть предметы, которые персонаж может подобрать, а затем надеть/снять

## Архитектурные виды

### Роли и случаи использования
Роли:
- Игрок
- Переводчик
- Дизайнер уровней

Случаи использования:
- Игрок хочет сыграть. У него есть не так много времени, игра не должна быть долгой. Значит:
  - Уровней не должно быть слишком много
  - У игры должен быть конец
- Переводчик хочет перевести игру на другой язык. Он не хочет иметь дело с кодом. Значит:
  - Все строковые литералы должны быть вынесены в файл, чтобы переводчик мог добавить такой же файл с переводом на другой язык
- Дизайнер уровней хочет изменить определенный уровень. Он не хочет иметь дело с кодом. Значит:
  - Уровни должны быть вынесены в файлы, чтобы их можно было править независимо от кода

### Типичный пользователь
Имя: Григорий

Возраст: 45 лет

Фото:

![Григорий](images/user.jpg)

Программист, пользуется ОС Linux, пользуется терминалом

В игры особо не играет, но в детстве играл

Во время рабочего времени или после работы сидит с открытым терминалом, хочет отдохнуть. Не чаще 1-2 раз в день

Хочет на время отвлечься от работы или отдохнуть вечером

### Композиция
![Components](images/components.svg)

Используем **слоистую архитектуру**. Также компоненты похожи на компоненты MVC, только у нас View не имеет доступа к Model. Map/Inventory/Help login — аналоги Controller в MVC

#### Input handler
Ждет ввод с клавиатуры, перенаправляет его в Game logic

#### Game logic
Логика игры. Реализуется с помощью паттерна Состояние. Система может находиться в одном из трех состояний: Map logic, Inventory logic, Help logic

#### Help logic
Показ управления и правил

#### Inventory logic
Работа с инвентарем

#### Map logic
Передвижение игрока по карте, подбор предметов в инвентарь

#### Game model
Содержит текущее состояние игры: что/кто в каком месте на карте находится, у кого сколько жизней, характеристик, что лежит в инвентаре героя, что надето на героя

#### Level generator
Создает карту для уровня из файла или с использованием случайности

#### Help GUI
Позволяет отобразить управление и правила игры

#### Inventory GUI
Позволяет отобразить инвентарь и надетые вещи

#### Map GUI
Позволяет отобразить игровую карту, лог игровых событий и характеристики героя, а также отобразить сообщение (например, при переходе на очередной уровень)

#### GUI library
Позволяет отобразить данные в консоли


### Логическая структура
![Classes](images/classes.svg)

#### Application
Содержит основной цикл программы: берет очередное нажатие у InputHandler и передает его в текущий State.
Если State, который вернули, не совпадает с предыдущим, то вызывает у него activate()

#### InputHandler
Позволяет считывать нажатие клавиш. Считывает нажатия с помощью метода readInput класса Terminal из выбранной библиотеки lanterna

#### State
Состояние игры. От состояния зависит, что будет изображено на экране и что будет происходить при нажатии определенной кнопки пользователем. Метод activate() активирует (выводит на экран нужное изображение) состояние

#### MapState
Состояние передвижения героя по карте.
Содержит логику по проверке и передвижении героя, подборе предметов.
Также показывает игроку текущие характеристики героя

#### MapFreeModeState
Состояние исследования карты без передвижения героя.
Содержит логику по перемещению курсора и отображении того, что находится в клетке под курсором.
Когда это состояние активируется курсор находится на клетке с героем

#### InventoryState
Состояние работы с инвентарем.
Содержит логику просмотра предметов в инвентаре, использование и отмену использования предметов

#### HelpState
Состояние просмотра информации об игре.
Показывает назначение клавиш

#### VictoryState
Состояние выигранной игры.
Показывает сообщение о том, что игрок выиграл

#### GameOverState
Состояние проигранной игры.
Показывает сообщение о том, что игрок проиграл

#### LevelFactory
Позволяет сгенерировать уровень (игровое поле) вместе с предметами и существами.
Уровень генерируется без героя, но возвращается его позиция.

Уровни хранятся в папке `resources/levels/`, уровень с именем `name_example` хранится в файле `name_example.txt`

Структура уровня:
1. Сначала идет игровое поле, состоящее из символов, которые определяют GroundType (их можно посмотреть в view.properties)
2. Затем идет пустая строка
3. После этого идет список предметов (возможно пустой) в формате `x y item_id`. Вместо `item_id` может быть `?`, тогда возьмется случайный предмет
4. Затем идет пустая строка
5. После этого идет позиция героя в формате `x y`

Пример уровня:
```text
..~
@.!

0 0 ?
0 1 healing_salve

1 0
```

#### ItemFactory
Позволяет создать предмет по id или случайный

Предметы хранятся списком в `items.json`:
```json
[
    {
        "type": "Reusable",
        "id": "gloves_of_haste",
        "name": "Gloves of Haste",
        "description": "A pair of magical gloves that seems to render weapons weightless.",
        "itemType": "Hands",
        "healthChange": 20,
        "maximumHealthChange": 20
    },
    {
        "type": "Disposable",
        "id": "tango",
        "name": "Tango",
        "description": "Forage to survive on the battlefield.",
        "healthChange": 20,
        "maximumHealthChange": 5
    }
]
```

#### GameModel
Модель игры: текущее состояние игрового поля, герой

#### GameField
Игровое поле, состоит из клеток, имеет размеры height на width

#### Cell
Клетка игрового поля. У клетки есть тип. На клетке могут находиться предметы и до 1 существа

#### GroundType
Тип клетки

#### Item
Предмет. Предмет может быть одноразовым или многоразовым. Предмет сам знает, как он подействует на героя. Предмет может быть неприменим в данный момент к герою (нельзя надеть 2 шляпы, например)

#### Creature
Существо. Может передвигаться по карте, имеет здоровье

#### Mob
Моб, может иметь различные стратегии поведения

#### RandomMobDecorator
Моб, который меняет свою стратегию на стратегию случайного блуждания на timeLimit шагов

#### MoveStrategy
Стратегия передвижения моба

#### CowardStrategy
Трусливая стратегия, если моб видит игрока на расстоянии не больше vision, то начинает убегать от него

#### AggressiveStrategy
Агрессивная стратегия, если моб видит игрока на расстоянии не больше vision, то начинает бежать к нему, чтобы ударить

#### PassiveStrategy
Пассивная стратегия, моб стоит на месте

#### Hero
Персонаж, которым управляет игрок. Может носить вещи

#### MapView
Показывает игровое поле и характеристики героя или клетки.
Чтобы изменения показались на экране, нужно вызвать метод show()

Макет для MapState:
![Map View](images/map_view.png)

Макет для MapFreeModeState:
![Map Free Mode View](images/map_free_mode_view.png)

#### InventoryView
Показывает предметы, выбранный предмет, характеристики выбранного предмета и характеристики героя.
Чтобы изменения показались на экране, нужно вызвать метод show()

Макет:
![Inventory View](images/inventory_view.png)

#### MessageView
Показывает сообщение по середине экрана.
Чтобы изменения показались на экране, нужно вызвать метод show()

Макет (текст должен быть посередине, а не слева):
![Help View](images/help_view.png)

#### Drawable
Изображение, которое можно менять

#### Image
Реализует интерфейс библиотеки lanterna, делегируя запросы TextImage.
Умеет создать ссылку на часть себя для удобства

#### GameWindow
Игровое окно, может создать Image, который оно сможет отобразить

#### GameSound
Позволять издать звуковой сигнал

### Взаимодействия и состояния

#### Диаграмма состояний игры
![States](images/state_diagram.svg)

Всего у игры 6 состояний:

* `MapState` -- передвижение по карте. Попадаем при нажатии клавиши `M`
* `MapFreeModeState` -- изучение карты. Попадаем при нажатии клавиши `F`
* `InventoryState` -- просмотр инвентаря. Попадаем при нажатии клавиши `I`
* `HelpState` -- просмотр информации об игре. Попадаем при нажатии клавиши `H`
* `VictoryState` -- состояние победы. Попадаем при победе
* `GameOverState` -- состояние проигрыша. Попадаем при проигрыше

#### Диаграмма обработки очередного хода игрока по передвижению героя
![Sequences](images/sequence_diagram.svg)

Всё начинается с того, что у `MapState` вызывается метод `handleInput`,
в который передаётся действие `InputType`, которое совершил пользователь.
`MapState` запрашивает у `GameModel` поле и игрока.
Далее `MapState` запрашивает клетку у `GameField`, в которую хочет перейти игрок.
Если переход возможен, тогда `MapState` получает из клетки предметы, передаёт их пользователю
и удаляет их из клетки. После этого, если тип клетки, например, огонь, то убавляет здоровье героя (`affect`).
Далее меняет позицию героя, изменяя данную информацию в герое и в клетке. В конце, происходит отрисовка
изменений, с помощью `MapView`.

Если же переход сделать не возможно, то с помощью `GameSound` издаётся звук.

## Rationale — причины принятых решений, за/против, альтернативы
Выбран язык **Kotlin**, так как у него достаточно производительности, есть библиотека для работы с консолью, хорошо с кроссплатформенностью, и наша команда хорошо знакома с этим языком программирования. То есть он удовлетворяет всем требованиям к системе. На других языках нам будет либо сложнее писать из-за отсутствия сборщика мусора (C/C++), либо из-за отсутствия опыта (Python, Go)

Для работы с консолью выбрана библиотека [lanterna](https://github.com/mabe02/lanterna), так как в ней есть все нужное, её API прост, и она до сих пор поддерживается. Альтернативы [JCurses](https://sourceforge.net/projects/javacurses) и [Charva](http://www.pitman.co.za/projects/charva/index.html) не поддерживаются и не имеют никаких преимуществ перед lanterna. Альтернативы найдены по запросу `ncurses java` в [статье](http://rememberjava.com/cli/2017/01/22/ncurses_terminal_libs.html)

Все константы должны быть вынесены в `properties` файлы
